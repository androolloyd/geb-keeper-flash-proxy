import { ContractApis, Erc20 } from '@reflexer-finance/geb-contract-api';
import { GebProviderInterface, MulticallRequest, ContractList, GebDeployment, BaseContractAPI, GebContractAPIConstructorInterface } from '@reflexer-finance/geb-contract-base';
import { ethers } from 'ethers';
import { GebProxyActions } from './proxy-action';
import { Safe } from './schema/safe';
/**
 * The main package used to interact with the GEB system. Includes [[deployProxy |helper functions]] for safe
 *  management and the [[contracts | contract interface object]] to directly call the smart-contracts.
 */
export declare class Geb {
    protected network: GebDeployment;
    /**
     * Object containing all GEB core smart-contracts instances for direct level interactions. All of the
     * following contracts object are one-to-one typed API to the underlying smart-contract. Read-only
     * functions that do not change the blockchain state return a promise of the return data. State modifying
     * function will return synchronously a pre-filled transaction request object:
     * ```
     * {
     *   to: "0x123abc.."
     *   data: "0xabab234ab..."
     * }
     * ```
     * This object follow the [[https://docs.ethers.io/v5/api/providers/types/#providers-TransactionRequest
     * TransactionRequest model of ethers.js]] (Also similar to the
     * [[https://web3js.readthedocs.io/en/v1.3.0/web3-eth.html#id84 | model used by web.js]]). The object can
     * be completed with properties such as ` from `, ` gasPrice `, ` gas ` (gas limit, web3.js ony) or
     * ` gasLimit ` (gas limit, ethers.js only). The object can then be passed to the `sendTransaction` of
     * [[https://docs.ethers.io/v5/api/signer/#Signer-sendTransaction|ehters.js]] or
     * [[https://web3js.readthedocs.io/en/v1.3.0/web3-eth.html#sendtransaction | web3.js]]
     *
     *  Example:
     *  ```typescript
     *  // Setup geb.js an ethers
     *  const provider = new ethers.providers.JsonRpcProvider('http://kovan.infura.io/<API KEY>')
     *  const wallet = new ethers.Wallet('<Private key>', provider)
     *  const geb = new Geb('kovan', provider)
     *
     *  // Contract read function: Fetch the debt ceiling
     *  const debtCeiling = await geb.contracts.safeEngine.globalDebtCeiling()
     *
     *  // State changing function: Manualy liquidate a SAFE
     *  const tx = geb.contracts.liquidationEngine.liquidateSAFE(ETH_A, '0x1234abc...')
     *  await wallet.sendTransaction(tx) // Send the Ethereum transaction
     *  ```
     *
     * Currently the following contracts ae available in this property:
     * - SAFEEngine
     * - AccountingEngine
     * - TaxCollector
     * - LiquidationEngine
     * - OracleRelayer
     * - GlobalSettlement
     * - DebtAuctionHouse
     * - PreSettlementSurplusAuctionHouse
     * - PostSettlementSurplusAuctionHouse
     * - SettlementSurplusAuctioneer
     * - GebSafeManager
     * - GetSafes
     * - BasicCollateralJoin
     * - CoinJoin
     * - Coin (RAI ERC20 contract)
     * - GebProxyRegistry
     * - FixedDiscountCollateralAuctionHouse (For ETH-A)
     * - Weth (ERC20)
     *
     * For detailed information about the functions of each contract we recommend referring directly to the
     * smart-contract [[https://github.com/reflexer-labs/geb | code]] and [[https://docs.reflexer.finance/ |
     * documentation]]
     */
    contracts: ContractApis;
    protected provider: GebProviderInterface;
    protected addresses: ContractList;
    /**
     * Constructor of the main Geb.js object.
     * @param  {GebDeployment} network Either `'kovan'`, `'mainnet'` or an actual list of contract addresses.
     * @param  {GebProviderInterface|ethers.providers.Provider} provider Either a Ethers.js provider or a Geb provider (Soon support for Web3 will be added)
     */
    constructor(network: GebDeployment, provider: GebProviderInterface | ethers.providers.Provider);
    /**
     * Given an address returns a GebProxyActions object to execute bundled operations.
     * Important: This requires the address to have deployed a GEB proxy through the proxy registry contract. It will throw a `DOES_NOT_OWN_HAVE_PROXY` error if the address specified does not have a proxy. Use the [[deployProxy]] function to get a new proxy.
     * @param ownerAddress Externally owned user account, Ethereum address that owns a GEB proxy.
     */
    getProxyAction(ownerAddress: string): Promise<GebProxyActions>;
    /**
     * Deploy a new proxy owned by the sender.
     */
    deployProxy(): import("@reflexer-finance/geb-contract-base").TransactionRequest;
    /**
     * Get the SAFE object given a `safeManager` id or a `safeEngine` handler address.
     * @param idOrHandler Safe Id or SAFE handler
     */
    getSafe(idOrHandler: string | number, collateralType?: string): Promise<Safe>;
    /**
     * Fetch the list of safes owned by an address. This function will fetch safes owned directly
     * through the safeManager and safes owned through the safe manager through a proxy. Safes owned
     * directly by the address at the safeEngine level won't appear here.
     *
     * Note that this function will make a lot of network calls and is therefore very slow. For
     * front-ends we recommend using pre-indexed data such as the geb-subgraph.
     *
     * @param  {string} address
     */
    getSafeFromOwner(address: string): Promise<Safe[]>;
    /**
     * Returns an object that can be used to interact with a ERC20 token.
     * Example:
     * ```typescript
     * const USDCAddress = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
     * const USDC = geb.getErc20Contract(USDCAddress)
     *
     * // Get 0xdefiisawesome's balance
     * const balance = USDC.balanceOf("0xdefiisawesome..")
     *
     * // Send 1 USDC to 0xdefiisawesome (USDC is 6 decimals)
     * const tx = USDC.transfer("0xdefiisawesome..", "1000000")
     * await wallet.sendTransaction(tx)
     * ```
     *
     * @param  {string} tokenAddress Token contract address
     * @returns Erc20
     */
    getErc20Contract(tokenAddress: string): Erc20;
    /** @ignore */
    multiCall<O1>(calls: [MulticallRequest<O1>]): Promise<[O1]>;
    /** @ignore */
    multiCall<O1, O2>(calls: [MulticallRequest<O1>, MulticallRequest<O2>]): Promise<[O1, O2]>;
    multiCall<O1, O2, O3>(calls: [MulticallRequest<O1>, MulticallRequest<O2>, MulticallRequest<O3>]): Promise<[O1, O2, O3]>;
    /** @ignore */
    multiCall<O1, O2, O3, O4>(calls: [MulticallRequest<O1>, MulticallRequest<O2>, MulticallRequest<O3>, MulticallRequest<O4>]): Promise<[O1, O2, O3, O4]>;
    /** @ignore */
    multiCall<O1, O2, O3, O4, O5>(calls: [MulticallRequest<O1>, MulticallRequest<O2>, MulticallRequest<O3>, MulticallRequest<O4>, MulticallRequest<O5>]): Promise<[O1, O2, O3, O4, O5]>;
    /** @ignore */
    multiCall<O1, O2, O3, O4, O5, O6>(calls: [MulticallRequest<O1>, MulticallRequest<O2>, MulticallRequest<O3>, MulticallRequest<O4>, MulticallRequest<O5>, MulticallRequest<O6>]): Promise<[O1, O2, O3, O4, O5, O6]>;
    /** @ignore */
    multiCall<O1, O2, O3, O4, O5, O6, O7>(calls: [MulticallRequest<O1>, MulticallRequest<O2>, MulticallRequest<O3>, MulticallRequest<O4>, MulticallRequest<O5>, MulticallRequest<O6>, MulticallRequest<O7>]): Promise<[O1, O2, O3, O4, O5, O6, O7]>;
    /**
     * Returns an instance of a specific geb contract given Geb contract API class constructor at a specified address
     *
     * @param  {GebContractAPIConstructorInterface<T>} gebContractClass Class from contracts or adminContracts
     * @param  {string} address Contract address of the instance
     * @param  {GebProviderInterface|ethers.providers.Provider} provider Either a Ethers.js provider or a Geb provider
     */
    static getGebContract<T extends BaseContractAPI>(gebContractClass: GebContractAPIConstructorInterface<T>, address: string, provider: GebProviderInterface | ethers.providers.Provider): T;
    /**
     * Returns an instance of a specific geb contract given a Geb contract API class at a specified address
     *
     * ```typescript
     * import { contracts } from "geb.js"
     * const safeEngine = geb.getGebContract(contracts.SafeEngine, "0xabcd123..")
     * const globalDebt = safeEngine.globalDebt()
     * ```
     *
     * @param  {GebContractAPIConstructorInterface<T>} gebContractClass Class from contracts or adminContracts
     * @param  {string} address Contract address of the instance
     */
    getGebContract<T extends BaseContractAPI>(gebContractClass: GebContractAPIConstructorInterface<T>, address: string): T;
}
