"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Geb = void 0;
var geb_contract_api_1 = require("@reflexer-finance/geb-contract-api");
var geb_contract_base_1 = require("@reflexer-finance/geb-contract-base");
var geb_ethers_provider_1 = require("@reflexer-finance/geb-ethers-provider");
var errors_1 = require("./errors");
var proxy_action_1 = require("./proxy-action");
var utils_1 = require("./utils");
var safe_1 = require("./schema/safe");
/**
 * The main package used to interact with the GEB system. Includes [[deployProxy |helper functions]] for safe
 *  management and the [[contracts | contract interface object]] to directly call the smart-contracts.
 */
var Geb = /** @class */ (function () {
    /**
     * Constructor of the main Geb.js object.
     * @param  {GebDeployment} network Either `'kovan'`, `'mainnet'` or an actual list of contract addresses.
     * @param  {GebProviderInterface|ethers.providers.Provider} provider Either a Ethers.js provider or a Geb provider (Soon support for Web3 will be added)
     */
    function Geb(network, provider) {
        this.network = network;
        if (
        // @ts-ignore
        provider.getBlockNumber !== undefined &&
            // @ts-ignore
            provider.getBlock !== undefined) {
            // It's an Ethers provider
            this.provider = new geb_ethers_provider_1.GebEthersProvider(provider);
        }
        else {
            this.provider = provider;
        }
        this.addresses = geb_contract_base_1.getAddressList(network);
        this.contracts = new geb_contract_api_1.ContractApis(network, this.provider);
    }
    /**
     * Given an address returns a GebProxyActions object to execute bundled operations.
     * Important: This requires the address to have deployed a GEB proxy through the proxy registry contract. It will throw a `DOES_NOT_OWN_HAVE_PROXY` error if the address specified does not have a proxy. Use the [[deployProxy]] function to get a new proxy.
     * @param ownerAddress Externally owned user account, Ethereum address that owns a GEB proxy.
     */
    Geb.prototype.getProxyAction = function (ownerAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var address;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.contracts.proxyRegistry.proxies(ownerAddress)];
                    case 1:
                        address = _a.sent();
                        if (address === utils_1.NULL_ADDRESS) {
                            throw new errors_1.GebError(errors_1.GebErrorTypes.DOES_NOT_OWN_HAVE_PROXY);
                        }
                        return [2 /*return*/, new proxy_action_1.GebProxyActions(address, this.network, this.provider)];
                }
            });
        });
    };
    /**
     * Deploy a new proxy owned by the sender.
     */
    Geb.prototype.deployProxy = function () {
        return this.contracts.proxyRegistry.build();
    };
    /**
     * Get the SAFE object given a `safeManager` id or a `safeEngine` handler address.
     * @param idOrHandler Safe Id or SAFE handler
     */
    Geb.prototype.getSafe = function (idOrHandler, collateralType) {
        return __awaiter(this, void 0, void 0, function () {
            var handler, isManaged, safeId, safeData, safeRights;
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(typeof idOrHandler === 'number')) return [3 /*break*/, 3];
                        if (collateralType) {
                            throw new errors_1.GebError(errors_1.GebErrorTypes.INVALID_FUNCTION_INPUT, 'Do not specify a collateral type when providing a SAFE Id.');
                        }
                        isManaged = true;
                        safeId = idOrHandler;
                        return [4 /*yield*/, this.multiCall([
                                this.contracts.safeManager.safes(idOrHandler, true),
                                this.contracts.safeManager.collateralTypes(idOrHandler, true),
                            ])];
                    case 1:
                        _a = _c.sent(), handler = _a[0], collateralType = _a[1];
                        if (handler === utils_1.NULL_ADDRESS) {
                            throw new errors_1.GebError(errors_1.GebErrorTypes.SAFE_DOES_NOT_EXIST, "Safe id " + idOrHandler + " does not exist");
                        }
                        return [4 /*yield*/, this.contracts.safeEngine.safes(collateralType, handler)];
                    case 2:
                        safeData = _c.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        // We're given a handler
                        if (!collateralType) {
                            throw new errors_1.GebError(errors_1.GebErrorTypes.INVALID_FUNCTION_INPUT, 'Collateral type needs to be specified when providing a SAFE handler');
                        }
                        handler = idOrHandler;
                        safeRights = void 0;
                        return [4 /*yield*/, this.multiCall([
                                this.contracts.safeEngine.safes(collateralType, handler, true),
                                this.contracts.safeEngine.safeRights(handler, this.contracts.safeManager.address, true),
                            ])
                            // If SafeManager has right over the safe, it's a managed safe
                        ];
                    case 4:
                        _b = _c.sent(), safeData = _b[0], safeRights = _b[1];
                        // If SafeManager has right over the safe, it's a managed safe
                        isManaged = !safeRights.isZero();
                        handler = idOrHandler;
                        _c.label = 5;
                    case 5: return [2 /*return*/, new safe_1.Safe(this.contracts, handler, safeData.generatedDebt, safeData.lockedCollateral, collateralType, isManaged, safeId)];
                }
            });
        });
    };
    /**
     * Fetch the list of safes owned by an address. This function will fetch safes owned directly
     * through the safeManager and safes owned through the safe manager through a proxy. Safes owned
     * directly by the address at the safeEngine level won't appear here.
     *
     * Note that this function will make a lot of network calls and is therefore very slow. For
     * front-ends we recommend using pre-indexed data such as the geb-subgraph.
     *
     * @param  {string} address
     */
    Geb.prototype.getSafeFromOwner = function (address) {
        return __awaiter(this, void 0, void 0, function () {
            var proxy, safes, safeId, _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.contracts.proxyRegistry.proxies(address)];
                    case 1:
                        proxy = _e.sent();
                        safes = [];
                        return [4 /*yield*/, this.contracts.safeManager.firstSAFEID(proxy)];
                    case 2:
                        safeId = _e.sent();
                        _e.label = 3;
                    case 3:
                        if (!!safeId.isZero()) return [3 /*break*/, 6];
                        _b = (_a = safes).push;
                        return [4 /*yield*/, this.getSafe(safeId.toNumber())];
                    case 4:
                        _b.apply(_a, [_e.sent()]);
                        return [4 /*yield*/, this.contracts.safeManager.safeList(safeId)];
                    case 5:
                        safeId = (_e.sent()).next;
                        return [3 /*break*/, 3];
                    case 6: return [4 /*yield*/, this.contracts.safeManager.firstSAFEID(address)];
                    case 7:
                        // Fetch safes owned directly
                        safeId = _e.sent();
                        _e.label = 8;
                    case 8:
                        if (!!safeId.isZero()) return [3 /*break*/, 11];
                        _d = (_c = safes).push;
                        return [4 /*yield*/, this.getSafe(safeId.toNumber())];
                    case 9:
                        _d.apply(_c, [_e.sent()]);
                        return [4 /*yield*/, this.contracts.safeManager.safeList(safeId)];
                    case 10:
                        safeId = (_e.sent()).next;
                        return [3 /*break*/, 8];
                    case 11: return [2 /*return*/, safes];
                }
            });
        });
    };
    /**
     * Returns an object that can be used to interact with a ERC20 token.
     * Example:
     * ```typescript
     * const USDCAddress = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"
     * const USDC = geb.getErc20Contract(USDCAddress)
     *
     * // Get 0xdefiisawesome's balance
     * const balance = USDC.balanceOf("0xdefiisawesome..")
     *
     * // Send 1 USDC to 0xdefiisawesome (USDC is 6 decimals)
     * const tx = USDC.transfer("0xdefiisawesome..", "1000000")
     * await wallet.sendTransaction(tx)
     * ```
     *
     * @param  {string} tokenAddress Token contract address
     * @returns Erc20
     */
    Geb.prototype.getErc20Contract = function (tokenAddress) {
        return new geb_contract_api_1.Erc20(tokenAddress, this.provider);
    };
    /**
     * Bundles several read only GEB contract call into 1 RPC single request. Useful for front-ends or apps that need to fetch many parameters from the contracts but want to minimize the network request and the load on the underlying Ethereum node.
     * The function takes as input an Array of GEB view contract calls.
     * **IMPORTANT**: You have to set the `multicall` parameter of the contract function to `true`, it is the always the last parameter of the function.
     * Multicall works for all contracts in the `Geb.contracts` and can be use with any contract that inherit the `BaseContractApi`. Note that it does not support non-view calls (Calls that require to pay gas and change the state of the blockchain).
     *
     * Example:
     * ```typescript
     * import { ethers } from "ethers"
     * import { Geb } from "geb.js"
     *
     * const provider = new ethers.providers.JsonRpcProvider("http://kovan.infura.io/...")
     * const geb = new Geb("kovan", provider);
     *
     * const [ globalDebt, collateralInfo ] = await geb.multiCall([
     *     geb.contracts.safeEngine.globalDebt(true), // !! Note the last parameter set to true.
     *     geb.contracts.safeEngine.collateralTypes(ETH_A, true),
     * ])
     *
     * console.log(`Current global debt: ${globalDebt.toString()}`)
     * console.log(`Current ETH_A debt: ${collateralInfo.debtAmount}`)
     * ```
     * @param  {MulticallRequest<T>[]} calls Call a read only GEB contract function. The GEB contract object needs to be called with the parameter `multicall` set to `true` as seen in the example above.
     * @returns Promise<T[]> Array with the result from their respective requests.
     */
    Geb.prototype.multiCall = function (calls) {
        return __awaiter(this, void 0, void 0, function () {
            var multiCall, send, results, a;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        multiCall = new geb_contract_api_1.Multicall(this.addresses.MULTICALL, this.provider);
                        send = calls.map(function (x) { return ({
                            target: x.to,
                            callData: x.data,
                        }); });
                        return [4 /*yield*/, multiCall.aggregate_readOnly(send)];
                    case 1:
                        results = _a.sent();
                        a = results.returnData.map(function (raw, i) {
                            return _this.provider.decodeFunctionData(raw, calls[i].abi);
                        });
                        return [2 /*return*/, a];
                }
            });
        });
    };
    /**
     * Returns an instance of a specific geb contract given Geb contract API class constructor at a specified address
     *
     * @param  {GebContractAPIConstructorInterface<T>} gebContractClass Class from contracts or adminContracts
     * @param  {string} address Contract address of the instance
     * @param  {GebProviderInterface|ethers.providers.Provider} provider Either a Ethers.js provider or a Geb provider
     */
    Geb.getGebContract = function (gebContractClass, address, provider) {
        if (
        // @ts-ignore
        provider.getBlockNumber !== undefined &&
            // @ts-ignore
            provider.getBlock !== undefined) {
            // It's an Ethers provider
            provider = new geb_ethers_provider_1.GebEthersProvider(provider);
        }
        return new gebContractClass(address, provider);
    };
    /**
     * Returns an instance of a specific geb contract given a Geb contract API class at a specified address
     *
     * ```typescript
     * import { contracts } from "geb.js"
     * const safeEngine = geb.getGebContract(contracts.SafeEngine, "0xabcd123..")
     * const globalDebt = safeEngine.globalDebt()
     * ```
     *
     * @param  {GebContractAPIConstructorInterface<T>} gebContractClass Class from contracts or adminContracts
     * @param  {string} address Contract address of the instance
     */
    Geb.prototype.getGebContract = function (gebContractClass, address) {
        return new gebContractClass(address, this.provider);
    };
    return Geb;
}());
exports.Geb = Geb;
//# sourceMappingURL=geb.js.map